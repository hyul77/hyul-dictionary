# 4_1.서버프로그램구현

## 개발환경

### 개발 환경 구축
- 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것
- 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정(성능, 편의성, 라이선스 등)

### 하드웨어 환경
- 사용자와의 인터페이스 역할을 하는 클라이언트(개인pc, 스마트폰)와 서비스 제공하는 서버로 구성
- 웹서버, 웹 애플리케이션서버(WAS), DB, File server

### 소프트웨어 환경
- 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성
- 시스템 소프트웨어 : OS, 웹 서버 및 WAS 운용을 위한 서버프로그램, DBMS
- 개발 소프트웨어 : 요구사항 관리 도구, 설계모델링 도구, 구현도구, 빌드도구 등

### 개발 언어의 선정 기준
- 적정성, 효율성, 이식성, 친밀성, 범용성

### 웹 서버 기능
- HTTPS : 요청을 받아 응답할 때 사용되는 프로토콜
- 통신 기록 : 처리한 요청들을 로그 파일로 기록
- 정적 파일 관리 : HTML CSS 이미지 등의 정적 파일들을 저장
- 대역폭 제한 : 네트워크 트래픽의 포화를 방지를 위해 응답 속도 제한
- 가상 호스팅 : 하나의 서버로 여러개의 도메인 이름을 연결
- 인증 : 합법적인 사용자인지 확인

### SW 아키텍처
- 소프트웨어를 구성하는 요소들간의 관계를 표현
- 기본 원리 : 모듈화, 추상화, 단계적 분해, 정보은닉

### 모듈화
- 시스템의 기능들을 모듈 단위로 나누는 것
- 모듈간의 결합도, 응집도가 중요한데 결합도 최소화, 응집도 최대화하는 것을 모듈화의 목표이다

### 추상화
- 문제의 전체적이고 포괄적인 개념을 설계, 구체화 시켜 나가는 것
- 과정, 자료, 제어 추상화

### 단계적 분해
- 상위의 개념으로부터 하위 개념으로 구체화시키는 분할법
- 하향식 설계 전략

### 정보 은닉
- 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근 못하게 하는 기법
- 다른 모듈에 영향을 주지않으므로 수정, 시험, 유지보수가 용이

### 상위 설계 <-> 하위 설계
- 아키텍처, 예비 설계 <-> 모듈, 상세 설계
- 전체적인 구조 <-> 내부 구조 및 행위
- 구조, DB, 인터페이스 <-> 컴포넌트, 자료구조, 알고리즘

### SW 아키텍처의 품질 속성
- 이해 관계자들이 요구하는 수준의 품질을 유지 보장 할 수 있게 설계되었는지 확인
- 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성
- 비즈니스 측면 : 시장 적시성, 비용 혜택, 예상 시스템 수명, 목표 시장, 공개 일정
- 아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성

### 협약에 의한 설계
- 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유
- 선행 조건, 결과 조건, 불변 조건




## 패턴

### 아키텍처 패턴
- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결방식을 의미

### 레이어 패턴
- 시스템을 계층으로 구분하여 구성하는 고전적인 패턴
- OSI 참조 모델

### 클라이언트-서버 패턴
- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
- 사용자가 클라이언트를 통해 서버에 요청시 클라이언트가 응답을 받아 사용자에게 제공하는 방식

### 파이프 필터 패턴
- 데이터 스트림 절차의 각 단계를 필터로 캡슐화 하여 파이프를 통해 전송
- 데이터 변환, 버퍼링, 동기화 등에 사용
- UNIX의 shell

### 모델 뷰 컨트롤러 패턴
- 서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴
- 사용자 요청 -> 컨트롤러, 핵심 기능, 데이터를 보관하는 모델, 뷰에 정보 출력 
- 여러개의 뷰 생성 가능
- 대화형 애플리케이션에 적합

### 마스터 슬레이브 패턴
- 처리된 결과물을 다시 돌려 받는 방식으로 작업

### 피어 투 피어 패턴
- 하나의 컴포넌트가 클라이언트가 될 수도 서버가 될 수도 있는 패턴

### 이벤트 버스 패턴 
- 메시지를 발행, 채널을 구독한 리스너가 메시지를 받이 이벤트 처리

### 블랙보드 패턴
- 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴

### 인터프리터 패턴
- 코드의 각 라인을 수행하는 방법을 지정, 기호마다 클래스를 갖도록 구성된 패턴

### 브로커 패턴
- 브로커 컴포넌트에 요청해 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴


## 객체지향

### 객체지향
- SW의 각 요소들을 객체로 만든 후 객체들을 조립해서 SW를 개발하는 기법
- 구성요소 : 객체, 클래스, 메시지
- 특징 : 캡슐화, 상속, 다형성, 연관성

### 객체
- 데이터와 이를 처리하기 위한 함수를 묶어 놓은 SW 모듈

### 클래스
- 공통된 속성과 연산을 갖는 객체의 집합

### 메시지
- 객체들 간의 상호작용에 사용되는 수단, 객체의 동작이나 연산을 일으키는 외부의 요구 사항

### 캡슐화
- 외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부 내용 은닉

### 상속
- 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

### 다형성
- 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
- 동일한 메소드명을 사용하며 같은 의미의 응답을 함

### 연관성
- 두 개 이상의 객체들이 상호 참조하는 관계
- 연관화, 분류화, 집단화, 일반화, 특수/상세화

### 객체지향 분석
- 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링 하는 작업

### 객체지향 분석의 방법론
- 럼바우 방법 : 객체, 동적, 기능 모델로 나누어 수행
- 부치 방법 : 미시적, 거시적 개발 프로세스를 모두 사용하며 분석 식별하고 클래스의 속성과 연산 정의
- Jacobson 방법 : 유스케이스를 강조하여 사용
- Coad와 Yourdon 방법 : E-R 다이어그램 사용, 객체 식별 -> 구조 식별 -> 주제 정의 -> 속성 인스턴스 연결 정의 -> 연산 메시지 연결정의
- Wirfs Brock 방법 : 분석과 설계간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행


### 럼바우의 분석 기법
- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
- 객체 모델링 -> 동적 모델링 -> 기능 모델링

### 객체지향 설계 원칙(SQLID)
- 단일 책임 원칙 : 객체는 하나의 책임만 가져야함
- 개방-폐쇄 원칙 : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계
- 리스코프 치환 원칙 : 자식 클래스는 최소한 부모 클래스의 기능은 수행
- 인터페이스 분리 원칙 : 사용하지않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야함
- 의존 역전 원칙 : 추상성이 높은 클래스와 의존 관계를 맺어야함
