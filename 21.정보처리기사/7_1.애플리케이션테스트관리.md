# 7_1.애플리케이션 테스트 관리
## 테스트
### 애플리케이션 테스트
- 애플리케이션의 결함을 찾는 행위
- 고객의 요구사항을 만족시키는지 확인, 기능을 수행하는지 검증
- 테스트의 기본원리 : 파레토 법칙, 살충제 패러독스, 오류-부재의 궤변
- 파레토 법칙 : 앱의 20%에 해당하는 코드에서 전체 결함의 80%가 발견
- 살충제 패러독스 : 동일한 케이스로 동일한 테스트를 반복하면 더이상 결함이 발견되지 않음
- 오류-부재의 궤변 : SW의 결함을 제거해도 요구사항을 만족시키지 못하면 품질이 높다 못함

### 프로그램 실행 여부에 따른 테스트
- 정적 테스트 : 명세서나 소스코드를 대상으로 분석, 코딩 표준, 코딩스타일, 복잡도, 결함등을 발견하기 위해 사용
 - 종류 : 워크스루, 인스펙션, 코드검사
- 동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트, 개발의 모든 단계에서 테스트를 수행
 - 종류 : 블랙박스 테스트, 화이트박스 테스트

### 테스트 기반에 따른 테스트
- 명세 기반 테스트 : 명세를 빠짐없이 테스트 케이스로 만들어 구현
 - 종류 : 동등 분할, 경계값 분석
- 구조 기반 테스트 : SW 내부의 논리 흐름에 따라 테스트 케이스를 작성
 - 종류 : 구문기반, 결정기반, 조건기반
- 경험 기반 테스트 : 유사 Sw 기술등에 대한 테스터의 경험 기반, 명세가 불충분, 테스트 시간에 제약있는 경우
 - 종류 : 에러추정, 체크리스트, 탐색적 테스팅

### 시각에 따른 테스트
- 검증 테스트 : 개발자 시각, 제품의 생산 과정 테스트, 명세서 대로 완성 되었는지
- 확인 테스트 : 사용자 시각, 제품의 결과를 테스트, 요구한대로 제품이 완성되었는지, 정상작동하는지

### 목적에 따른 테스트
- 회복 테스트 : 여러가지 결함을 줘 실패한 후 복구되는지 확인
- 안전 테스트 : 불법적인 침입에서 보호할 수 있는지 확인
- 강도 테스트 : 과도한 정보량, 빈도로 과부하시에도 정상적으로 실행되는지 확인
- 성능 테스트 : 실시간 성능, 효율성 진단, 응답시간, 처리량 등 확인
- 구조 테스트 : 논리적인 경로, 소스코드의 복잡도 등 평가
- 회귀 테스트 : 변경, 수정된 코드에 새로운 결함이 없는지 확인
- 병행 테스트 : 변경된 SW와 기존 SW에 동일한 데이터를 입력하여 결과 비교

### 화이트박스 테스트
- 모듈의 원시코드를 오픈 시킨 상태, 모든 경로 테스트해 테스트 케이스 설계
- 직접 관찰할 수 있음
- 모든 문장을 한번 이상 실행함으로 수행
- 기초 경로 검사 : 절차적 설계의 논리적 복잡성 측정
- 제어 구조 검사 : 조건 검사, 루프 검사, 데이터 흐름 검사

### 화이트박스 테스트의 검증 기준
- 문장 검증 기준 : 모든 구문이 한번 이상 수행 되도록 설계
- 분기 검증 기준 : 모든 조건문에 결과가 한번 이상 수행 되도록 설계, (=결정 검증 기준)
- 조건 검증 기준 : 개별 조건식의 결과가 한번 이상 수행 되도록 설계
- 분기/조건 기준 : 분기, 조건 검증 기준을 모두 만족하는 설계, 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스 설계

### 블랙박스 테스트
- 각 기능이 완전히 작동되는 것을 입증하는 테스트, 기능테스트라고도 함
- 요구사항 명세를 보고 테스트
- 구현된 기능을 테스트
- 인터페이스를 통해 실시
- 동치 분할 검사 : 타당한, 타당하지않은 입력 자료의 개수를 균등하게 하여 테스트
- 경계값 분석 : 경계값에서 오류가 발생할 확률이 높다는 점 이용, 입력 조건의 경계값을 테스트케이스로 선정
- 원인-효과 그래프 검사 : 입력 데이터간의 간계와 출력에 영향을 미치는 상황을 체계적으로 분석, 효용성이 높은 테스트 케이스를 선정
- 오류 예측 검사 : 과거의 경험이나 확인자의 감각으로 테스트
- 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공,, 결과가 출력되는지 테스트

### 개발 단계에 따른 애플리케이션 테스트
- 요구사항->분석->설계->구현 (소프트웨어 개발단계)
- 단위테스트->통합테스트->시스템테스트->인수테스트(테스트 단계)

### 단위테스트
- SW 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트
- 자료구조, 독립적 기초 경로, 오류처리경로, 경계조건등을 검사
- 요구사항을 기반으로한 기능성 테스트를 최우선, 구조기반, 명세기반 테스트로 나누지만 주로 구조 기반테스트 시행

### 통합테스트
- 단위 테스트가 끝난후 결합하여 하나의 시스템으로 안성 시키는 과정에서의 테스트
- 상호작용오류를 검사
- 비점진적 통합방식 : 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트(빅뱅 통합 테스트 방식)
- 점진적 통합방식 : 모듈 단위로 단계적으로 통합하면서 테스트 (하향식 통합, 상향식 통합, 혼합식 통합 테스트)

### 시스템테스트
- 개발된 SW가 해당 시스템에서 완벽하게 수행되는가 점검
- 기능적 요구사항, 비기능적 요구사항으로 구분 각각 만족하는지 테스트

### 인수테스트
- 사용자 요구사항을 충족하는지 중점 테스트
- 사용자가 직접 테스트한다
- 알파테스트 : 개발자의 장소에서 사용자가 개발자 앞에서 행함, 오류와 사용상의 문제점을 함께 확인, 기록
- 베타테스트 : 선정된 최종 사용자가 여러 사용자 앞에서 행함, 실업무를 가지고 사용자가 직접 테스트

### 하향식 통합테스트
- 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
- 하향식 통합 테스트 절차 
 - 주요 제어 모듈의 종속 모듈들은 스텁으로 대체
 - 깊이, 넓이 우선등의 통합 방식에 따라 스텁들이 하나씩 실제 모듈로 교체
 - 모듈이 통합될 때 마다 테스트
 - 새로운 오류가 발생하지 않음을 보증하기위해 회귀 테스트 진행
 - 스텁 : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구, 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈

### 상향식 통합테스트
- 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트
- 상향식 통합 테스트 절차
 - 클러스터로 결합
 - 입출력을 확인하기 위해 더미 모듈인 드라이버 작성
 - 클러스트 단위로 테스트
 - 테스트 완료된 클러스터는 프로그램 구조의 상위로 이동, 결합하고 드라이버는 실제 모듈로 대체
 - 테스트 드라이버 : 하위 모듈 호출, 파라미터 전달, 모듈 테스트 수행 후의 결과를 도출

### 혼합식 통합테스트
- 하위 수준에서는 상향식, 상위 수준에서는 하향식 통합을 사용, 최적의 테스트 지원
- 샌드위치식 통합 테스트

### 회귀 테스트
- 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인
- 테스트된 프로그램의 테스팅을 반복
- 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트, 새로운 오류가 안났음을 보증

### 테스트 케이스
- 구현된 SW가 요구사항에 적절히 준수 했는지 확인 하기 위해 설계된 테스트 항목에 대한 명세서
- 오류방지, 필요한인력, 시간 등의 자원 낭비를 줄일 수 있음

### 테스트 시나리오
- 테스트 케이스를 적용하는 순서에 따라 여러개의 테스트 케이스를 묶은 집합
- 테스트 케이스를 적용하는 구체적인 절차를 명세
- 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정

### 테스트 오라클
- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입, 비교하는 기법
- 예상 겨로가를 계산하거나 확인
- 제한된 검증, 수학적 기법, 자동화 기능
- 참 오라클 : 모든 테스트 케이스의 입력값에 대해 기대하는 결과를 제공하는 오라클
- 샘플링 오라클 : 특정한 몇몇 테스트 케이스의 입력 값들에만 기대하는 결과 제공, 전수 테스트가 불가능
- 추정 오라클 : 특정 테스트 케이스의 입력값에 대해 기대하는 결과를 제공, 나머지 입력 값들에 대해 추정
- 일관성 검사 오라클 : 애플리케이션에 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지

### 테스트 자동화 도구
- 정적 분석 도구 : 실행하지 않고 분석, 코딩 표준, 스타일, 복잡도, 남은 결함 등을 발견하기 위해 사용
- 테스트 실행 도구 : 스크립트 언어를 사용하여 테스트, 데이터와 수행방법등이 포함된 스크립트를 작성 후 실행
- 성능 테스트 도구 : 처리량, 응답시간, 경과시간, 자원사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트 수행, 목표 달성여부 확인
- 테스트 통제 도구 : 계획, 관리, 수행, 결함 관리 등을 수행
- 테스트 하네스 도구 : 실행될 환경을 시물레이션하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구

### 테스트 하네스의 구성요소
- 테스트 하네스 : 애플리케이션의 컴포넌트 및 모듈을 테스트 하는 환경의 일부분, 테스트를 지원하기 위해 생성된 코드와 데이터 의미
- 테스트 드라이버 : 테스트 대상의 하위 모듈을 호출, 파라미터 전달, 모듈 테스트 수행 후 결과 도출
- 테스트 스텁 : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
- 테스트 슈트 : 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스 집합
- 테스트 케이스 : 사용자의 요구사항을 덩확히 준수했는지 확인하기 위한 값, 조건, 기대 결과 등의 항목의 명세서
- 테스트 스크립트 : 자동화된 테스트 실행 절차에 대한 명세서
- 목 오브젝트 : 사전에 사용자의 행위를 조건부로 입력둬 그 상황에 맞는 예정된 행위를 수행하는 객체

### 결함
- 오류발생, 작동실패 등 SW가 개발자가 설계한 것과 다르게 동작하거나 다른 결과를 발생되는 것 의미
- 사용자 예상 결과와 실행 결과 간의 차이나 업무 내용과의 불일치 등으로 인해 변경이 필요한 부분도 결함에 해당

### 결함 상태 추적
- 테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리해야함
- 결함 관리 측정 지표
- 결함 분포 : 모듈 또는 컴포넌트의 특정 속성에 대한 결함 수 측정
- 결함 추세 : 테스트 진행 시간에 따른 결함 수의 추이 분석
- 결함 에이징 : 특정 결함 상태로 지속되는 시간 측정

### 결함 분류
- 시스템 결함 : 애플리케이션 환경이나 데이터 베이스 처리에서 발생
- 기능 결함 : 기획, 설계, 업무 시나리오 등의 단계에서 유입
- GUI 결함 : 사용자 화면 설계에서 발생된 결함
- 문서 결함 : 기획자, 사용자, 개발자 간의 의사소통 및 기록이 원할하지 않아 발생된 결함

### 결함 심각도/우선순위
- 결함 심각도 : 애플리케이션에 발생한 결함이 전체 시스템에 미치는 치명도를 나타내는 척도
- 결함 우선순위 : 발견된 결함 처리에 신속성을 나타내는 척도

### 애플리케이션 성능 측정 지표
- 처리량 : 일정 시간 내에 애플리케이션이 처리하는 일의양
- 응답 시간 : 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때 까지 걸린 시간
- 경과 시간 : 작업 의뢰한 시간부터 처리가 완료될 때 까지 걸린 시간
- 자원 사용률 : 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량등 자원 사용률

### 성능 테스트 도구
- 애플리케이션에 부하나 스트레스를 가해 측정 지표를 점검하는 도구
- JMeter : HTTP, FTP등 다양한 프로토콜을 지원하는 부하 테스트 도구
- LoadUI : 서버 모니터링, Drag&Drop 등 사용자의 편리성이 강화된 부하 테스트 도구로 HTTP, JDBC등 다양한 프로토콜 지원
- OpenSTA : HTTP, HTTPS 프로토콜에 대한 부하 테스트 및 생산품 모니터링 도구

### 시스템 모니터링 도구
- 애플리케이션이 실행 되었을 때 시스템 자원의 사용량을 확인하고 분석하는 도구
- Scouter : 단일 뷰 통합/실시간 모니터링, 인프라 통합 모니터링 도구, 성능을 모니터링/통제
- Zabbix : 웹기반 서버, 서비스, 애플리케이션 등 모니터링 도구

### 복잡도/ 시간 복잡도
- 복잡도 : 시스템이나 시스템 구성요소 또는 소프트웨어의 복잡한 정도를 의미
- 시간복잡도: 알고리즘을 수행하기 위해 프로세스가 수행하는 여산 횟수를 수치화한 것
- 빅오 표기법: 알고리즘의 실행시간이 최악일 떄 표기 방법

### 순환 복잡도
- 논리적인 복잡도를 측정하기 위한 SW의 척도
- 맥케이브 순환도 
- 제어 흐름 G에서 순환 복잡도V(G)는 화살표로 구분되는 각 영역의 개수를 계산

### 소스코드 최적화
- 나쁜 코드를 배제하고 클린 코드로 작성
- 클린 코드 : 누구나 쉽게 이해, 수정, 추가할 수 있는 단순, 명료한 코드
- 나쁜 코드 : 로직이 복잡하고 이해하기 어려운 코드
- 스파게티 코드 : 코드의 로직이 서로 복잡하게 얽혀있는 코드
- 외계인 코드 : 아주 오래되거나 참고 문서 또는 개발자가 없어 유지보수 작업이 어려운 코드

### 클린 코드 작성 원칙
- 가독성, 단순성, 의존성배제, 중복성최소화, 추상화

### 소스코드 품질 분석 도구
- 정적 분석 도구 : pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura
- 동적 분석 도구 : Avalanche, Valgrind