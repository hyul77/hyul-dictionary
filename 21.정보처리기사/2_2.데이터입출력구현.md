# 2_2.데이터 입출력 구현
## 데이터
### 데이터 전환 (ETL)
- 운영 중인 시스템에 축적된 데이터를 추출하여 새로 개발할 정보 시스템에 운영할 수 있게 변환한 후 적재하는 과정
- 데이터 이행, 데이터 이관

### 데이터 검증
- 원천 시스템의 데이터를 목적 시스템의 데이터로 전환하는 과정을 검증
- 검증 방법 / 검증 단계

### 오류 데이터 측정 및 정제
- 고품질의 데이터를 운영 및 관리하기 위해 수행
- 데이터 품질 분석 -> 오류 데이터 측정 -> 오류 데이터 정제 순으로 진행

### RTO/RPO
- RTO(목표 복구 시간) : 비상사태 시점으로부터 복구되어 가동될 떄까지의 소요 시간을 의미
- RPO(목표 복구 시점) : 비상사태 시점으로부터 데이터를 복구할 수 있는 기준점을 의미

### 임의 접근통제(DAC)
- 데이터에 접근하는 사용자의 신원에 따라 접근 권한이 다름
- 데이터 소유자가 지정, 제어
- 부여된 권한을 다른 사용자에게 허가할 수 있음

### 강제 접근통제(MAC)
- 주체와 객체의 등급을 비교하여 접근 권한을 부여
- 시스템이 접근 통제권한을 지정
- 사용자별로 인가 등급을 부여

### 역할 기반 접근통제(RBAC)
- 사용자의 역할에 따라 접근 권한 부여
- 중앙관리자가 접근통제 권한을 지정
- 임의, 강제 접근통제의 단점을 보완
- 다중 프로그래밍 환경에 최적화

### 스토리지
- 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연겨하는 기술
- DAS, NAS, SAN 존재

### DAS
- 서버와 저장장치를 전용 케이블로 직접 연결
- 외장하드, 직접 연결 방식

### NAS
- 서버와 저장자치를 네트워크를 통해 연결
- 별도의 파일 관리 기능이 있는 NAS 스토리지가 내장된 저장장치를 직접 관리
- 다른 서버에서도 접근할 수 있어 파일 공유 가능

### SAN
- DAS의 빠른처리, NAS으 파일 공유 장점을 혼합한 방식
- 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성
- 파이버채널 스위치 이용
- 서버들이 저장장치 및 파일을 공유 가능

### 암호화
- 송수신자들만 내용을 알수 있도록 평문을 암호문으로 변환하는 과정
- 암호화 과정 : 평문 -> 암호문
- 복호화 과정 : 암호문 -> 평문
- 암호화 기법(개인키 암호 방식, 공개키 암호 방식)

## 자료구조
### 자료구조
- 자료를 기억장치의 공간 내에 저장하는 방법과 자료 간의 관계 처리방법을 연구
- 선형 구조 : 배열, 리스트, 스택, 큐, 데크
- 비선형 구조 : 트리, 그래프

### 배열
- 크기와 타입이 동일한 자료들을 순서대로 나열한 자료의 집합

### 스택
- LIFO 방식, 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조
- 오버플로, 언더플로가 발생할 수 있음

### 큐
- FIFO 방식 , 리스트의 한쪽에서는 삽입, 한쪽에서는 삭제가 이루어지는 구조

### 그래프
- 정점과 간선의 두 집합으로 이루어진 자료구조
- 사이클이 없는 그래프를 트리라 함
- 간선의 방향성 유무에 따라 방향그래프 무방향 그래프로 구분
- 방향 그래프의 최대 간선 수 : n(n-1)
- 무방향 그래프의 최대 간선 수 : n(n-1)/2

### 트리
- 정점과 선분을 이용해 사이클이 없는 그래프의 특수한 형태

### 트리 용어
- Node : 트리의 기본 요소
- Root Node : 맨 위에 있는 노드
- Degree : 각 노드에서 뻗어 나오는 가지 수
- Terminal Node, Leaf Node : 자식이 없는 노드
- Level : Root Node가 1로 가정, 자식 노드로 내려갈 때마다 1씩 증가
- Depth : Tree에서 노드가 가질 수 있는 최대 Level
- Forest : 여러개의 트리가 모여있는 것
- 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수

## Search
### Preorder
- Root -> Left -> Right

### Inorder
- Left -> Root -> Right

### Postorder
- Left -> Right -> Root

### Infix 표기 -> Prefix
- X = A / B * (C + D) + E => X + * / A B + C D E

### Infix 표기 ->  Postfix
- X = A / B * (C + D) + E => X A B / C D + * E + =

### Postfix 표기 -> Infix
- A B C - / D E F + * + => A / (B - C) + D * (E + F)

## 정렬
### 삽입 정렬
- 이미 순서화된 것에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬
- 시간 복잡도 O(n^2)

### 선택 정렬
- 최소값을 찾아 첫번째 레코드 위치에 놓고 나머지 중에서 다시 최소 값을 찾아 두번 째 레코드 위치에 놓는 방식을 반복
- 시간 복잡도 O(n^2)

### 버블 정렬
- 인접한 두개의 레코드 키 값을 비교해 크기에 따라 서로 교환하는 정렬 방식
- 시간 복잡도 O(n^2)

### 퀵 정렬
- 키를 기준으로 작은 값은 왼쪽 큰 값은 오른쪽 서브 파일에 분해 시키는 과정을 반복
- 시간 복잡도 O(nlogn)

### 힙 정렬
- 전이진 트리를 이용한 정렬 방식
- 시간 복잡도 O(nlogn)

### 2-Way 합병 정렬
- 이미 정렬되어잇는 두개의 파일을 한 개의 파일로 합병하는 정렬 방식
- 시간 복잡도 O(nlogn)